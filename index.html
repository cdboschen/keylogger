<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Key Identification System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        .section {
            margin-bottom: 30px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 15px;
        }
        
        .section h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 5px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        input[type="text"] {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }
        
        #video, #identifyVideo {
            width: 100%;
            max-width: 400px;
            border-radius: 10px;
            margin: 10px 0;
            display: none;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        #video.active, #identifyVideo.active {
            display: block;
        }
        
        .preview-canvas {
            max-width: 400px;
            border-radius: 10px;
            margin: 10px 0;
            display: none;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .preview-canvas.active {
            display: block;
        }
        
        .key-item {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .key-item img {
            max-width: 200px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .key-item h3 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .delete-btn {
            background: #e74c3c;
            padding: 8px 16px;
            font-size: 14px;
        }
        
        .delete-btn:hover {
            background: #c0392b;
        }
        
        #keyList {
            margin-top: 20px;
        }
        
        .match-result {
            background: white;
            padding: 20px;
            margin: 15px 0;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-left: 5px solid #667eea;
        }
        
        .match-result.best-match {
            border-left-color: #2ecc71;
            background: #e8f8f5;
        }
        
        .match-result h3 {
            color: #2ecc71;
            margin-bottom: 10px;
        }
        
        .match-score {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
            margin: 10px 0;
        }
        
        .no-match {
            background: #fff3cd;
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid #ffc107;
            color: #856404;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #667eea;
            font-size: 18px;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .storage-info {
            background: #e3f2fd;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 14px;
            color: #1976d2;
        }
        
        .export-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #ddd;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîë Key Identification System</h1>
        
        <div class="section">
            <h2>Add New Key</h2>
            <input type="text" id="keyLabel" placeholder="Enter key label (e.g., 'Front Door', 'Car Key')">
            <input type="text" id="keyNotes" placeholder="Additional notes (optional)">
            <video id="video" autoplay></video>
            <canvas id="captureCanvas" class="preview-canvas"></canvas>
            <div>
                <button id="addKeyBtn" onclick="startAddKey()">üì∑ Add Key</button>
                <button id="captureBtn" class="hidden" onclick="captureAndSave()">üì∏ Capture Photo</button>
            </div>
            <div class="storage-info" id="storageInfo"></div>
        </div>
        
        <div class="section">
            <h2>Identify Unknown Key</h2>
            <video id="identifyVideo" autoplay></video>
            <canvas id="identifyCanvas" class="preview-canvas"></canvas>
            <div id="identifyResults"></div>
            <div>
                <button id="identifyKeyBtn" onclick="startIdentify()">üîç Identify Key</button>
                <button id="captureIdentifyBtn" class="hidden" onclick="captureAndIdentify()">üì∏ Capture Photo</button>
            </div>
        </div>
        
        <div class="section">
            <h2>Stored Keys</h2>
            <button onclick="loadKeys()">üîÑ Refresh List</button>
            <button onclick="clearAllKeys()" class="delete-btn">üóëÔ∏è Clear All Keys</button>
            <div id="keyList"></div>
            
            <div class="export-section">
                <h3 style="color: #667eea; margin-bottom: 10px;">Backup & Restore</h3>
                <button onclick="exportKeys()">üì• Export Keys</button>
                <button onclick="document.getElementById('importFile').click()">üì§ Import Keys</button>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importKeys(event)">
            </div>
        </div>
    </div>

    <script>
        let videoStream = null;
        let identifyStream = null;
        let capturedImage = null;
        let identifyImage = null;
        let db;
        
        // Initialize IndexedDB
        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('KeyDatabase', 1);
                
                request.onerror = () => {
                    console.error('DB error:', request.error);
                    reject(request.error);
                };
                
                request.onsuccess = () => {
                    db = request.result;
                    console.log('DB initialized');
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('keys')) {
                        db.createObjectStore('keys', { keyPath: 'id' });
                        console.log('Object store created');
                    }
                };
            });
        }
        
        async function startAddKey() {
            const label = document.getElementById('keyLabel').value.trim();
            
            if (!label) {
                alert('Please enter a key label first');
                return;
            }
            
            try {
                const video = document.getElementById('video');
                
                // Start camera
                videoStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' } 
                });
                video.srcObject = videoStream;
                video.classList.add('active');
                
                // Show capture button, hide add key button
                document.getElementById('addKeyBtn').classList.add('hidden');
                document.getElementById('captureBtn').classList.remove('hidden');
                
            } catch (err) {
                alert('Error accessing camera: ' + err.message);
            }
        }
        
        async function captureAndSave() {
            const label = document.getElementById('keyLabel').value.trim();
            const notes = document.getElementById('keyNotes').value.trim();
            const video = document.getElementById('video');
            const canvas = document.getElementById('captureCanvas');
            const context = canvas.getContext('2d');
            
            try {
                // Capture photo
                const maxSize = 200;
                let width = video.videoWidth;
                let height = video.videoHeight;
                
                if (width > height) {
                    if (width > maxSize) {
                        height = height * (maxSize / width);
                        width = maxSize;
                    }
                } else {
                    if (height > maxSize) {
                        width = width * (maxSize / height);
                        height = maxSize;
                    }
                }
                
                canvas.width = width;
                canvas.height = height;
                context.drawImage(video, 0, 0, width, height);
                
                // Convert to grayscale
                const imageData = context.getImageData(0, 0, width, height);
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    data[i] = gray;
                    data[i + 1] = gray;
                    data[i + 2] = gray;
                }
                context.putImageData(imageData, 0, 0);
                
                capturedImage = canvas.toDataURL('image/jpeg', 0.5);
                canvas.classList.add('active');
                
                // Stop camera
                if (videoStream) {
                    videoStream.getTracks().forEach(track => track.stop());
                    video.classList.remove('active');
                }
                
                // Reset buttons
                document.getElementById('addKeyBtn').classList.remove('hidden');
                document.getElementById('captureBtn').classList.add('hidden');
                
                // Save to database
                await initDB();
                
                const key = {
                    id: Date.now(),
                    label: label,
                    notes: notes,
                    image: capturedImage,
                    timestamp: new Date().toISOString()
                };
                
                console.log('Saving key:', key.label);
                
                const transaction = db.transaction(['keys'], 'readwrite');
                const objectStore = transaction.objectStore('keys');
                const request = objectStore.add(key);
                
                request.onsuccess = () => {
                    console.log('Key saved successfully');
                    document.getElementById('keyLabel').value = '';
                    document.getElementById('keyNotes').value = '';
                    
                    // Hide canvas after a moment
                    setTimeout(() => {
                        canvas.classList.remove('active');
                    }, 2000);
                    
                    capturedImage = null;
                    
                    alert('Key saved successfully!');
                    loadKeys();
                };
                
                request.onerror = () => {
                    console.error('Save error:', request.error);
                    alert('Error saving key: ' + request.error);
                };
                
            } catch (err) {
                alert('Error: ' + err.message);
            }
        }
        
        async function startIdentify() {
            try {
                const video = document.getElementById('identifyVideo');
                
                // Start camera
                identifyStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' } 
                });
                video.srcObject = identifyStream;
                video.classList.add('active');
                
                // Show capture button, hide identify button
                document.getElementById('identifyKeyBtn').classList.add('hidden');
                document.getElementById('captureIdentifyBtn').classList.remove('hidden');
                
            } catch (err) {
                alert('Error accessing camera: ' + err.message);
            }
        }
        
        async function captureAndIdentify() {
            const video = document.getElementById('identifyVideo');
            const canvas = document.getElementById('identifyCanvas');
            const context = canvas.getContext('2d');
            const resultsDiv = document.getElementById('identifyResults');
            
            try {
                // Capture photo
                const maxSize = 200;
                let width = video.videoWidth;
                let height = video.videoHeight;
                
                if (width > height) {
                    if (width > maxSize) {
                        height = height * (maxSize / width);
                        width = maxSize;
                    }
                } else {
                    if (height > maxSize) {
                        width = width * (maxSize / height);
                        height = maxSize;
                    }
                }
                
                canvas.width = width;
                canvas.height = height;
                context.drawImage(video, 0, 0, width, height);
                
                // Convert to grayscale
                const imageData = context.getImageData(0, 0, width, height);
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    data[i] = gray;
                    data[i + 1] = gray;
                    data[i + 2] = gray;
                }
                context.putImageData(imageData, 0, 0);
                
                identifyImage = canvas.toDataURL('image/jpeg', 0.5);
                canvas.classList.add('active');
                
                // Stop camera
                if (identifyStream) {
                    identifyStream.getTracks().forEach(track => track.stop());
                    video.classList.remove('active');
                }
                
                // Reset buttons
                document.getElementById('identifyKeyBtn').classList.remove('hidden');
                document.getElementById('captureIdentifyBtn').classList.add('hidden');
                
                // Show loading
                resultsDiv.innerHTML = '<div class="loading"><div class="spinner"></div><p>Analyzing key...</p></div>';
                
                // Get stored keys
                await initDB();
                const keys = await getAllKeys();
                
                if (keys.length === 0) {
                    resultsDiv.innerHTML = '<div class="no-match">No keys in database. Please add some keys first.</div>';
                    return;
                }
                
                // Compare with stored keys
                const matches = await compareWithStoredKeys(identifyImage, keys);
                
                // Display results
                displayMatches(matches, resultsDiv);
                
            } catch (err) {
                alert('Error: ' + err.message);
            }
        }
        
        async function getAllKeys() {
            await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['keys'], 'readonly');
                const objectStore = transaction.objectStore('keys');
                const request = objectStore.getAll();
                
                request.onsuccess = () => {
                    console.log('Retrieved keys:', request.result.length);
                    resolve(request.result);
                };
                request.onerror = () => reject(request.error);
            });
        }
        
        async function compareWithStoredKeys(capturedImage, storedKeys) {
            const matches = [];
            
            for (const key of storedKeys) {
                const similarity = await compareImages(capturedImage, key.image);
                matches.push({
                    key: key,
                    similarity: similarity
                });
            }
            
            matches.sort((a, b) => b.similarity - a.similarity);
            return matches;
        }
        
        async function compareImages(img1Data, img2Data) {
            return new Promise((resolve) => {
                const canvas1 = document.createElement('canvas');
                const canvas2 = document.createElement('canvas');
                const ctx1 = canvas1.getContext('2d');
                const ctx2 = canvas2.getContext('2d');
                
                const img1 = new Image();
                const img2 = new Image();
                
                let loaded = 0;
                
                function checkLoaded() {
                    loaded++;
                    if (loaded === 2) {
                        const size = 100;
                        canvas1.width = canvas2.width = size;
                        canvas1.height = canvas2.height = size;
                        
                        ctx1.drawImage(img1, 0, 0, size, size);
                        ctx2.drawImage(img2, 0, 0, size, size);
                        
                        const data1 = ctx1.getImageData(0, 0, size, size).data;
                        const data2 = ctx2.getImageData(0, 0, size, size).data;
                        
                        let diff = 0;
                        for (let i = 0; i < data1.length; i += 4) {
                            diff += Math.abs(data1[i] - data2[i]);
                        }
                        
                        const maxDiff = size * size * 255;
                        const similarity = ((maxDiff - diff) / maxDiff) * 100;
                        
                        resolve(similarity);
                    }
                }
                
                img1.onload = checkLoaded;
                img2.onload = checkLoaded;
                img1.src = img1Data;
                img2.src = img2Data;
            });
        }
        
        function displayMatches(matches, resultsDiv) {
            if (matches.length === 0) {
                resultsDiv.innerHTML = '<div class="no-match">No matches found.</div>';
                return;
            }
            
            let html = '';
            const topMatches = matches.slice(0, 3);
            
            topMatches.forEach((match, index) => {
                const isBestMatch = index === 0 && match.similarity > 50;
                const matchClass = isBestMatch ? 'match-result best-match' : 'match-result';
                
                html += `
                    <div class="${matchClass}">
                        ${isBestMatch ? '<h3>‚úì Best Match</h3>' : '<h3>Possible Match #' + (index + 1) + '</h3>'}
                        <div class="match-score">${match.similarity.toFixed(1)}% Similar</div>
                        <p><strong>Label:</strong> ${match.key.label}</p>
                        ${match.key.notes ? `<p><strong>Notes:</strong> ${match.key.notes}</p>` : ''}
                        <p><strong>Added:</strong> ${new Date(match.key.timestamp).toLocaleDateString()}</p>
                        <img src="${match.key.image}" alt="${match.key.label}" style="max-width: 200px; border-radius: 8px; margin-top: 10px;">
                    </div>
                `;
            });
            
            if (matches[0].similarity < 50) {
                html = '<div class="no-match">‚ö†Ô∏è No confident matches found. The best match is only ' + matches[0].similarity.toFixed(1) + '% similar.</div>' + html;
            }
            
            resultsDiv.innerHTML = html;
        }
        
        async function loadKeys() {
            const keys = await getAllKeys();
            const keyList = document.getElementById('keyList');
            
            if (keys.length === 0) {
                keyList.innerHTML = '<p>No keys stored yet.</p>';
                updateStorageInfo();
                return;
            }
            
            keyList.innerHTML = keys.map(key => `
                <div class="key-item">
                    <h3>${key.label}</h3>
                    ${key.notes ? `<p><strong>Notes:</strong> ${key.notes}</p>` : ''}
                    <p><strong>Added:</strong> ${new Date(key.timestamp).toLocaleString()}</p>
                    <img src="${key.image}" alt="${key.label}">
                    <br>
                    <button class="delete-btn" onclick="deleteKey(${key.id})">Delete</button>
                </div>
            `).join('');
            
            updateStorageInfo();
        }
        
        async function deleteKey(id) {
            if (confirm('Are you sure you want to delete this key?')) {
                await initDB();
                const transaction = db.transaction(['keys'], 'readwrite');
                const objectStore = transaction.objectStore('keys');
                objectStore.delete(id);
                
                await new Promise((resolve) => {
                    transaction.oncomplete = resolve;
                });
                
                loadKeys();
            }
        }
        
        async function clearAllKeys() {
            if (confirm('Are you sure you want to delete ALL keys? This cannot be undone.')) {
                await initDB();
                const transaction = db.transaction(['keys'], 'readwrite');
                const objectStore = transaction.objectStore('keys');
                objectStore.clear();
                
                await new Promise((resolve) => {
                    transaction.oncomplete = resolve;
                });
                
                loadKeys();
                alert('All keys have been deleted.');
            }
        }
        
        async function updateStorageInfo() {
            const keys = await getAllKeys();
            
            let totalSize = 0;
            keys.forEach(key => {
                totalSize += key.image.length;
            });
            
            const sizeMB = (totalSize / 1024 / 1024).toFixed(2);
            
            const infoDiv = document.getElementById('storageInfo');
            infoDiv.innerHTML = `
                üìä ${keys.length} keys stored | ~${sizeMB} MB used | IndexedDB (can store 100s of keys)
            `;
        }
        
        async function exportKeys() {
            const keys = await getAllKeys();
            if (keys.length === 0) {
                alert('No keys to export');
                return;
            }
            
            const dataStr = JSON.stringify(keys, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `keys-backup-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            
            alert(`Exported ${keys.length} keys successfully!`);
        }
        
        async function importKeys(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const importedKeys = JSON.parse(e.target.result);
                    
                    await initDB();
                    const transaction = db.transaction(['keys'], 'readwrite');
                    const objectStore = transaction.objectStore('keys');
                    
                    let count = 0;
                    for (const key of importedKeys) {
                        key.id = Date.now() + Math.random();
                        objectStore.add(key);
                        count++;
                    }
                    
                    transaction.oncomplete = () => {
                        alert(`Imported ${count} keys successfully!`);
                        loadKeys();
                    };
                    
                } catch (err) {
                    alert('Error importing keys: ' + err.message);
                }
            };
            
            reader.readAsText(file);
            event.target.value = '';
        }
        
        window.onload = async () => {
            await initDB();
            loadKeys();
        };
    </script>
</body>
</html>
